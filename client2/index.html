<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

    <title>Babylon.js sample code</title>

    <script src="https://cdn.socket.io/4.6.0/socket.io.min.js"
            integrity="sha384-c79GN5VsunZvi+Q/WObgk2in0CbZsHnjEqvFxC5DxHn9lTfNce2WW6h2pH6u/kF+"
            crossorigin="anonymous"></script>

    <!-- Bootstrap -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/css/bootstrap.min.css" integrity="sha384-rbsA2VBKQhggwzxH7pPCaAqO46MgnOM80zW1RWuH61DGLwZJEdK2Kadq2F9CUG65" crossorigin="anonymous">

    <!-- fontawesome icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha512-iecdLmaskl7CVkqkXNQ/ZH/XLlvWZOJyj7Yy7tcenmpD1ypASozpmT/E0iPtmFIB46ZmdtAc9eNBvH0H/ZpiBw==" crossorigin="anonymous" referrerpolicy="no-referrer" />

    <link rel="stylesheet" href="./assets/css/lobby.css">
    <link rel="stylesheet" href="./assets/css/round-info.css">
    <link rel="stylesheet" href="./assets/css/weapon-info.css">
    <link rel="stylesheet" href="./assets/css/player-stats.css">
    <link rel="stylesheet" href="./assets/css/player-coords.css">
    <link rel="stylesheet" href="./assets/css/overlay.css">

    <script src="https://code.jquery.com/jquery-3.6.4.min.js" integrity="sha256-oP6HI9z1XaZNBrJURtCoUT5SUnxFr8s3BzRl+cbzUq8=" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.6.0/js/bootstrap.min.js"></script>

    <!-- Babylon.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.2/dat.gui.min.js"></script>
    <script src="https://assets.babylonjs.com/generated/Assets.js"></script>
    <script src="https://preview.babylonjs.com/ammo.js"></script>
    <script src="https://preview.babylonjs.com/cannon.js"></script>
    <script src="https://preview.babylonjs.com/Oimo.js"></script>
    <script src="https://preview.babylonjs.com/earcut.min.js"></script>
    <script src="https://preview.babylonjs.com/babylon.js"></script>
    <script src="https://preview.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
    <script src="https://preview.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script>
    <script src="https://preview.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
    <script src="https://preview.babylonjs.com/loaders/babylonjs.loaders.js"></script>
    <script src="https://preview.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
    <script src="https://preview.babylonjs.com/gui/babylon.gui.min.js"></script>
    <script src="https://preview.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>
    <style>
        html, body {
            overflow: hidden;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
        }

        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
        }

        #canvasZone {
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body class="bg-dark">
    <div class="overlay">
        <div id="UI-reloading-indicator" style="display: none;">
            RELOADING
        </div>
        <div id="UI-hold-f-to-buy" style="display: none;">
            <h3 class="text-white">Hold <span class="text-success" id="KEYBINDINGS_BUY_WEAPON">F</span> to buy <span id="item-to-buy">AKM</span> for $<span id="item-cost">0</span></h3>
        </div>
    </div>
    <div class="player-coords">
        <span class="mx-1">x: <span id="player-coords-x">0</span></span>
        <span class="mx-1">y: <span id="player-coords-y">0</span></span>
        <span class="mx-1">z: <span id="player-coords-z">0</span></span>
    </div>
    <div id="round-info">
        <h4>Round: <span id="round-number">0</span></h4>
    </div>
    <div class="player left skewright small weapon-ammo">
        <h5 class="text-white">Ammo: <span id="ui-weapon-ammo">0</span></h5>
    </div>

    <div class="player left skewright small player-money">
        <h5 class="text-white">Money: $<span id="ui-player-money">0</span></h5>
    </div>

    <div class="player right skewleft player-health">
        <h5 class="skewright text-white">Health</h5>
        <div class="health-bar skewright">
            <div class="percentage" id="UI-player-health"></div>
        </div>
    </div>

<!--    <div class="d-flex justify-content-center">-->
<!--        <div class="ui text-center">-->
<!--            <div class="btn-wrapX">-->
<!--                <img id="akm" class="slot" width="2000" src="https://freepngimg.com/thumb/assault%20rifle/38-akm-kalash-russian-assault-rifle-png-thumb.png">-->
<!--                <img id="pistol" class="slot" src="https://garderoben.se/images/normal/glock-17-gen4-gbb-6-mm-side_26411-44720.png">-->
<!--            </div>-->
<!--        </div>-->
<!--    </div>-->

    <!-- Modal -->
    <div class="modal fade" id="exampleModalCenter" tabindex="-1" role="dialog" aria-labelledby="exampleModalCenterTitle" aria-hidden="true">
        <div class="modal-dialog modal-dialog-centered" role="document">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="exampleModalLongTitle">Mod Menu</h5>
                </div>
                <div class="modal-body">
                    <div class="form-check">
                        <input class="form-check-input" type="checkbox" value="" id="TOGGLE_NOCLIP">
                        <label class="form-check-label" for="TOGGLE_NOCLIP">
                            NoClip
                        </label>
                    </div>
                    <div class="row mt-3">
                        <div class="col-sm-4">
                            <input class="form-check-input" type="checkbox" value="" id="TOGGLE_WALKSPEED">
                            <label for="TOGGLE_WALKSPEED" class="form-label">Walk Speed</label>
                        </div>
                        <div class="col-sm-8">
                            <input type="range" class="form-range" id="RANGE_WALKSPEED" min="0" max="10">
                        </div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-dismiss="modal">Close</button>
                    <button type="button" class="btn btn-primary">Save changes</button>
                </div>
            </div>
        </div>
    </div>

    <div id="canvasZone"><canvas id="renderCanvas"></canvas></div>

<script type="text">
        var canvas = document.getElementById("renderCanvas");

        var startRenderLoop = function (engine, canvas) {
            engine.runRenderLoop(function () {
                if (sceneToRender && sceneToRender.activeCamera) {
                    sceneToRender.render();
                }
            });
        }

        var engine = null;
        var scene = null;
        var sceneToRender = null;

        // var createDefaultEngine = function() { return new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true,  disableWebGL2Support: false}); };

        var createScene = function () {
            var scene = new BABYLON.Scene(engine);
            let dT = engine.getDeltaTime();
            function updateDT() {
                dT = engine.getDeltaTime();
            }

            {
                var advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI('UI');

                // HIDDEN - NOT USED ANY MORE
                // var sv = new BABYLON.GUI.ScrollViewer();
                // sv.name = 'mysv';
                // sv.thickness = 3;
                // sv.color = 'green';
                // sv.width = 0; // original: 1
                // sv.height = 0.2;
                // sv.background = 'black';
                // sv.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;
                // sv.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;
                // // console.log(sv);
                //
                // advancedTexture.addControl(sv);

                // var tb = new BABYLON.GUI.TextBlock();
                // tb.name = 'mytb';
                // tb.textWrapping = BABYLON.GUI.TextWrapping.WordWrap;
                // tb.resizeToFit = true;
                // tb.paddingTop = '0%';
                // tb.paddingLeft = '10px';
                // tb.paddingRight = '5px'
                // tb.paddingBottom = '0%';
                // tb.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
                // tb.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
                // tb.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
                // tb.textVerticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
                // tb.fontSize = '13px';
                // tb.fontFamily = 'Courier New';
                // tb.color = 'red';
                // tb.background = 'yellow';

                // sv.addControl(tb);

                // // build our own console.log() replacement... called console.out()
                // console.out = function (text) {
                //     tb.text += '\n\n' + '> ' + text;
                //     if (sv.verticalBar) {
                //         var vbar = sv.verticalBar;
                //         console.log(sv.vbar);
                //         vbar.color = 'cornflowerblue';
                //         vbar._value = 1;
                //     }
                // }
                // // replacement for console.clear()... console.wipe()
                // console.wipe = function () {
                //     // sv.verticalBar.value = 0;
                //     tb.text = '';
                // }

                // sv.onReadyObservable.add(console.log("sv ORO"));
                // sv.onAfterDrawObservable.add(console.log('sv drawn'));
                // sv.verticalBar.onValueChangedObservable.add(console.log('vb change'));
            }

            // ammo label
            var ammocount = new BABYLON.GUI.TextBlock();
            ammocount.leftInPixels = canvas.width/2.1;
            ammocount.text = auam+"";
            ammocount.color = "red";
            ammocount.fontSize = 24;
            advancedTexture.addControl(ammocount);

            // crosshair
            var ammocount1 = new BABYLON.GUI.TextBlock();
            ammocount1.text = "+";
            ammocount1.color = "pink";
            ammocount1.fontSize = 24;
            advancedTexture.addControl(ammocount1);

            // enemy health bar
            // var sheal = new BABYLON.GUI.Rectangle();
            // sheal.width = 0.2;
            // sheal.height = "25px";
            // sheal.cornerRadius = 20;
            // sheal.color = "black";
            // sheal.thickness = 3;
            // sheal.background = "green";
            // advancedTexture.addControl(sheal);
            // sheal.linkWithMesh(target);
            // sheal.linkOffsetY = -80;


            // ADDED
            canvas.onclick = function() {
                canvas.requestPointerLock();
            }

            // ADDED
            canvas.addEventListener('pointerlockchange', lockChangeLog, false);

            // ADDED
            function lockChangeLog() {
                if (canvas.pointerLockElement === canvas) {
                    control = true;
                    divObj.innerHTML = "The pointer is locked. Press Esc to unlock.";
                    canvas.addEventListener("mousemove", mousemoveCallback, false);
                } else {
                    control = false;
                    divObj.innerHTML = "The pointer is unlocked.";
                    canvas.removeEventListener("mousemove", mousemoveCallback, false);
                }
            }



            function mousemoveCallback(event) {
                console.log('here')
                var demo = requestAnimationFrame(mousemoveCallback);
            }

            // Lights - ADDED
            var light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);

            // ADDED
            var camera = new BABYLON.FreeCamera("camera", new BABYLON.Vector3(0, 25, 0), scene);
            camera.attachControl(canvas, true);
            camera.keysUp = [87];
            camera.keysDown = [83];
            camera.keysLeft = [65];
            camera.keysRight = [68];
            camera.inertia = 0.2;
            camera.fov = 1.5;
            camera.minZ = 0;
            camera.angularSensibility = 500;
            camera.speed = 2.5;
            scene.gravity = new BABYLON.Vector3(0, -0.6, 0);
            scene.collisionsEnabled = true;
            scene.enablePhysics()
            camera.checkCollisions = true;
            camera.applyGravity = true;
            camera.ellipsoid = new BABYLON.Vector3(0.25, 1.5, 0.25);
            camera._needMoveForGravity = true;


            // gun - ADDED
            var akm = new BABYLON.TransformNode();
            akm.parent = camera;
            camera.fov = 1;
            akm.position = new BABYLON.Vector3(0.5, -9990.7, 0.5);
            akm.rotation.x = -0.01;
            // load gun model
            BABYLON.SceneLoader.ImportMesh("", "https://dl.dropbox.com/s/kqnda4k2aqx8pro/", "AKM.obj", scene, function (newMeshes) {
                var mat = new BABYLON.StandardMaterial("", scene);
                mat.diffuseTexture = new BABYLON.Texture("https://dl.dropbox.com/s/isvd4dggvp3vks2/akm_diff.tga");
                mat.bumpTexture = new BABYLON.Texture("https://dl.dropbox.com/s/hiuhjsp4pckt9pu/akm_norm.tga");
                mat.specularTexture = new BABYLON.Texture("https://dl.dropbox.com/s/f3samm7vuvl0ez4/akm_spec.tga");
                for (var index = 0; index < newMeshes.length; index++) {
                    let ak = newMeshes[index];
                    ak.material = mat;
                    ak.scaling.x = 0.05;
                    ak.scaling.y = 0.05;
                    ak.scaling.z = 0.05;
                    ak.isPickable = false;
                    ak.parent = akm;
                }
            });

            // gun - ADDED
            var pistol = new BABYLON.TransformNode();
            pistol.parent = camera;
            camera.fov = 1;
            pistol.position = new BABYLON.Vector3(4.0, -3.0, 4.0);
            pistol.rotation.y = -1.7;
            pistol.rotation.z = 0.01;
            // load gun model
            BABYLON.SceneLoader.ImportMesh("", "./assets/models/guns/", "G17.glb", scene, function (newMeshes) {
                var mat = new BABYLON.StandardMaterial("", scene);
                mat.diffuseTexture = new BABYLON.Texture("https://dl.dropbox.com/s/isvd4dggvp3vks2/akm_diff.tga");
                for (var index = 0; index < newMeshes.length; index++) {
                    let ak = newMeshes[index];
                    ak.material = mat;
                    ak.scaling.x = 0.2;
                    ak.scaling.y = 0.2;
                    ak.scaling.z = 0.2;
                    ak.isPickable = false;
                    ak.parent = pistol;
                }
            });






            // ADDED
            // var box = BABYLON.MeshBuilder.CreateBox("box", {width: 10, height: 5, depth: 5}, scene);
            // box.position.z = 20;
            // box.checkCollisions = true;
            // var boxTexture = new BABYLON.StandardMaterial("boxTexture", scene);
            // boxTexture.diffuseTexture = new BABYLON.Texture("./assets/textures/wooden_box_01.jpg", scene);
            // // assign the texture to the box
            // box.material = boxTexture;

            // ADDED
            var recoilm = new BABYLON.Animation("recoilm", "position.z", 30, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE);
            var remkeys = [];
            remkeys.push({
                frame: 0,
                value: 0.5
            });
            remkeys.push({
                frame: 1,
                value: -0.03
            });
            remkeys.push({
                frame: 5,
                value: 0.5
            });
            remkeys.push({
                frame: 6,
                value: 0.2
            });
            remkeys.push({
                frame: 7,
                value: -0.06
            });
            remkeys.push({
                frame: 11,
                value: 0.2
            });
            recoilm.setKeys(remkeys);
            akm.animations.push(recoilm);

            // regular: akm.position = new BABYLON.Vector3(0.5, -0.7, 0.5);
            //aim: akm.position = new BABYLON.Vector3(0, -0.4125, 0.2);

            // // ADDED
            // var ground0 = BABYLON.Mesh.CreateGround("ground0", 250, 250, 2, scene);
            // ground0.material = new BABYLON.GridMaterial("gmat0", scene);
            // ground0.checkCollisions = true;

            // // ADDED
            // var ground1 = BABYLON.Mesh.CreateGround("ground1", 250, 250, 2, scene);
            // ground1.material = new BABYLON.GridMaterial("gmat1", scene);
            // ground1.position.z = 125;
            // ground1.rotation.x = -Math.PI/6;
            // ground1.checkCollisions = true;

            // // stairs - ADDED
            // var box = new BABYLON.Mesh.CreateBox("box", 5, scene);
            // box.position.y = -2;
            // box.checkCollisions = true;
            // box.type = "wall"
            // var box1 = new BABYLON.Mesh.CreateBox("box1", 5, scene);
            // box1.position.y = -1.5;
            // box1.position.z = 1;
            // box1.checkCollisions = true;
            // var box2 = new BABYLON.Mesh.CreateBox("box2", 5, scene);
            // box2.position.y = -1;
            // box2.position.z = 2;
            // box2.checkCollisions = true;
            // var box3 = new BABYLON.Mesh.CreateBox("box2", 5, scene);
            // box3.position.y = -0.5;
            // box3.position.z = 3;
            // box3.checkCollisions = true;
            // var box4 = new BABYLON.Mesh.CreateBox("box4", 5, scene);
            // box4.position.y = 0;
            // box4.position.z = 4;
            // box4.checkCollisions = true;
            // var box5 = new BABYLON.Mesh.CreateBox("box5", 5, scene);
            // box5.position.y = 0.5;
            // box5.position.z = 5;
            // box5.checkCollisions = true;

            var health = 1;

            var target = BABYLON.Mesh.CreateSphere("target", 12, 5, scene);
            target.name = 'target'
            target.position.y = 50;
            target.health = 500;
            target.position.x = Math.random() * 20 - 10; // Set x position randomly between -10 and 10
            target.position.z = Math.random() * 20 - 10; // Set z position randomly between -10 and 10
            target.material = new BABYLON.StandardMaterial("mat", scene);
            target.material.emissiveColor = new BABYLON.Color3(health, health, health);

            var targetHealth = 100;
            // Create an array to store the target meshes
            var zombies = [];

            function checkObstacle(zombie, direction, distance) {
                var ray = new BABYLON.Ray(zombie.position.add(new BABYLON.Vector3(0, 0.1, 0)), direction);
                var hit = scene.pickWithRay(ray, function (mesh) { return mesh != zombie && mesh != ground0; }); // exclude the zombie and ground meshes from the collision check
                if (hit.pickedMesh && hit.distance < distance) {
                    return true; // there is an obstacle between the zombie and the player
                } else {
                    return false; // there is no obstacle between the zombie and the player
                }
            }

            // Create 1 targets
            for (var i = 0; i < 1; i++) {
                var zombie = BABYLON.MeshBuilder.CreateCylinder("zombie", {height: 4, diameter: 2, tessellation: 10}, scene);
                // zombie.scaling.y = 0.5; // Set the scaling of the cylinder to make it half the original height

                zombie.name = 'zombie'
                // zombie.position.y = 10;
                zombie.position.y = 10
                zombie.position.x = Math.random() * 20 - 10; // Set x position randomly between -10 and 10
                zombie.position.z = Math.random() * 20 - 10; // Set z position randomly between -10 and 10
                zombie.material = new BABYLON.StandardMaterial("mat", scene);
                zombie.health = targetHealth
                zombie.material.emissiveColor = new BABYLON.Color3(zombie.health, zombie.health, zombie.health);

                zombie.physicsImpostor = new BABYLON.PhysicsImpostor(zombie, BABYLON.PhysicsImpostor.SphereImpostor, { mass: 0, restitution: 0, friction: 0.5, applyGravity: false }, scene);
                zombie.physicsImpostor.physicsBody.collisionFilterGroup = 0; // set collision group to 2 for zombies

                // enemy health bar
                var enemyHealthBar = new BABYLON.GUI.Rectangle();
                enemyHealthBar.width = "100px";
                enemyHealthBar.height = "10px";
                enemyHealthBar.cornerRadius = 20;
                enemyHealthBar.color = "black";
                enemyHealthBar.thickness = 3;
                enemyHealthBar.background = "green";
                advancedTexture.addControl(enemyHealthBar);
                enemyHealthBar.linkWithMesh(zombie);
                enemyHealthBar.linkOffsetY = -80;

                zombie.healthBar = enemyHealthBar

                zombies.push(zombie);
            }

            var followRange = 100;
            var zombieSpeed = 0.005;
            var zombieGravity = -30;



            scene.registerBeforeRender(function() {
                const player = camera;
                // Iterate over the zombies array and update their positions
                // Update the direction of the zombie based on the player's position
                for (var i = 0; i < zombies.length; i++) {
                    var zombie = zombies[i];

                    // Set the zombie's Y position to 0
                    zombie.position.y = 1;

                    // Calculate the distance between the zombie and the player
                    var distance = BABYLON.Vector3.Distance(zombie.position, player.position);

                    // If the distance is within the follow range, move the zombie towards the player
                    if (distance <= followRange) {
                        // Calculate the direction from the zombie to the player
                        var direction = player.position.subtract(zombie.position);

                        // Normalize the direction vector
                        direction.normalize();

                        // Multiply the direction by the zombie's speed and delta time
                        direction.scaleInPlace(zombieSpeed * scene.getEngine().getDeltaTime());

                        // Move the zombie towards the player
                        zombie.moveWithCollisions(direction);
                    }
                }
            })

            var translate = function (mesh, direction, power) {
                mesh.physicsImpostor.setLinearVelocity(
                    mesh.physicsImpostor.getLinearVelocity().add(direction.scale(power)
                    )
                );
            }

            // create a blood texture
            var bloodTexture = new BABYLON.StandardMaterial("bloodTexture", scene);
            bloodTexture.diffuseTexture = new BABYLON.Texture("./assets/textures/blood_01.png", scene);
            bloodTexture.diffuseTexture.hasAlpha = true; // enable transparency
            bloodTexture.emissiveColor = BABYLON.Color3.Red();
            bloodTexture.disableLighting = true; // disable lighting on the texture
            bloodTexture.billboardMode = BABYLON.Material.BILLBOARDMODE_Y; // make sure texture faces up

            // create a blood splatter on the ground
            function spawnBlood(position) {
                var blood = BABYLON.MeshBuilder.CreateGround("blood", {width: 1, height: 1, subdivisions: 1}, scene);
                blood.position.copyFrom(position);
                blood.position.y = 0.05; // offset slightly above ground to prevent z-fighting
                blood.material = bloodTexture;
                blood.rotation.y = Math.random() * 20 - 1000
                // blood.billboardMode = BABYLON.AbstractMesh.BILLBOARDMODE_Y; // make sure texture faces up
            }


            var bloodSprites = []

            function PEW() {
                console.log('shoot');

                var bulletMesh = new BABYLON.Mesh("bulletMesh", scene);
                var bullet = BABYLON.Mesh.CreateSphere("bullet", 12, 1, scene, false, BABYLON.Mesh.DEFAULTSIDE, bulletMesh);
                bullet.position.x = camera.position.x;
                bullet.position.y = camera.position.y;
                bullet.position.z = camera.position.z;
                bullet.physicsImpostor = new BABYLON.PhysicsImpostor(bullet, BABYLON.PhysicsImpostor.SphereImpostor, { mass: 0.25, restitution: 0 }, scene);
                translate(bullet, camera.getForwardRay().direction, 2000);

// delete bullet after time
                setTimeout(() => {
                    bullet.dispose()
                }, 3000)

// Create a ray from the bullet's position and direction
                var ray = new BABYLON.Ray(bullet.position, camera.getForwardRay().direction);

                var hitZombie = scene.pickWithRay(ray, (mesh) => {
                    return mesh.name === "zombie";
                })

                // Check if the ray intersects with the target mesh
                var hit = scene.pickWithRay(ray, function(mesh) {
                    return mesh.name === "target";
                });

                var hitWall = scene.pickWithRay(ray, (mesh) => {
                    return mesh.type === "wall";
                })

                if (hitWall.pickedMesh) {
                    console.log('hit wall')
                }

                if (hitZombie.pickedMesh) {
                    console.log("Bullet hit the zombie!");
                    console.log(hitZombie.pickedMesh)
                    console.log(hitZombie.pickedMesh.health);
                    hitZombie.pickedMesh.health -= 10;
                    // hitZombie.pickedMesh.healthBar.background = "red";
                    hitZombie.pickedMesh.healthBar.width = hitZombie.pickedMesh.health + "px";

                    spawnBlood(zombie.position);

                    if (hitZombie.pickedMesh.health <= 0) {
                        hitZombie.pickedMesh.dispose();
                        hitZombie.pickedMesh.healthBar.dispose();

                        // Remove the zombie from the scene and the zombies array
                        var index = zombies.indexOf(hitZombie.pickedMesh);
                        if (index > -1) {
                            zombies.splice(index, 1);
                            hitZombie.pickedMesh.dispose();
                        }
                    }
                }

                if (hit.pickedMesh) {
                    console.log("Bullet hit the target!");
                    console.log(hit.pickedMesh.health);
                    hit.pickedMesh.health -= 1;
                    if (hit.pickedMesh.health <= 0) {
                        hit.pickedMesh.dispose();
                    }
                }



                // check if the shootedball intersects with the target mesh
                // if (bullet.intersectsMesh(target)) {
                //     health -= 0.1;
                //     shootedball.dispose();
                //     console.log('hit target');
                // }
                //
                // if (bullet.intersectsMesh(ground1)) {
                //     console.log('hit ground1')
                // }
                // if (bullet.intersectsMesh(ground0)) {
                //     console.log('hit ground0')
                // }


                // scene.registerAfterRender(function() {
                //     if (shootedball.intersectsMesh(target, false)) {
                //         health -= 0.1;
                //         shootedball.dispose();
                //         console.log('here')
                //     }
                // });





                // var ray = camera.getForwardRay(999); // shoot range
                // var hit = scene.pickWithRay(ray);

                // let rayHelper = new BABYLON.RayHelper(ray);
                // rayHelper.show(scene);
                //
                // if (hit.pickedMesh == target){
                //    health -= 0.1;
        	    // } else if (hit.pickedMesh == ground0) {
                //     camera.position = hit.pickedPoint;
                //     camera.position.y += 5;
                // } else {
                //     //camera.position = ray.origin.clone().add(ray.direction.scale(100));
                // }
            }

            var wj = true;
            var grav = -0.6;
            var speed = 2.5;
            var spood = 0;
            var care = true;

            /*var map = {};
            scene.actionManager = new BABYLON.ActionManager(scene);
            scene.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnKeyDownTrigger, function (evt) {
                if (evt.sourceEvent.shiftKey) {
                    speed = 5;
                } else {
                    speed = 2.5;
                }
                if (evt.sourceEvent.spaceKey) {
                    if (wj == true) {
                        grav = 0.7;
                        wj = false;
                        spood += 0.5;
                    }
                }
                map[evt.sourceEvent.key] = evt.sourceEvent.type == "keydown";
            }));
            scene.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnKeyUpTrigger, function (evt) {
                map[evt.sourceEvent.key] = evt.sourceEvent.type == "keydown";
            }));

            function keypress() {

                if (map[" "]) {
                    if (wj == true) {
                        grav = 0.7;
                        wj = false;
                        spood += 0.5;
                    }
                };

                if ((map["r"] || map ["R"])) {
                    if (care == true && aure == 0) {
                        aure = 100;
                        akm.position = new BABYLON.Vector3(0.5, -0.7, 0.5);
                        camera.fov = 1.5;
                        reload.play();
                    }
                };

            }*/

            var akmSLOT = document.getElementById("akm");
            var pistolSLOT = document.getElementById("pistol");

            var onKeyDown = function(event) {

                switch (event.keyCode) {
                    case 49: // 1 - ADDED
                        console.log('selected akm')
                        akm.setEnabled(true);
                        pistol.setEnabled(false);
                        akmSLOT.classList.add("selected");
                        pistolSLOT.classList.remove("selected");
                        break
                    case 50: // 2 - ADDED
                        console.log('selected pistol')
                        akm.setEnabled(false);
                        pistol.setEnabled(true);
                        pistolSLOT.classList.add("selected");
                        akmSLOT.classList.remove("selected");
                        break
                    case 51: // 3
                    function throwGrenade() {
                        var grenade = BABYLON.Mesh.CreateSphere("grenade", 16, 0.5, scene);
                        grenade.position.copyFrom(camera.position);
                        grenade.physicsImpostor = new BABYLON.PhysicsImpostor(grenade, BABYLON.PhysicsImpostor.SphereImpostor, { mass: 0.25, restitution: 0.5 }, scene);
                        translate(grenade, camera.getForwardRay().direction, 20);



                        setTimeout(function() {
                            // Create explosion effect
                            // var explosion = BABYLON.Mesh.CreateSphere("explosion", 16, 5, scene);
                            // explosion.position.copyFrom(grenade.position);
                            // var explosionTexture = new BABYLON.StandardMaterial("explosionTexture", scene);
                            // explosionTexture.diffuseTexture = new BABYLON.Texture("./assets/textures/fire_01.jpg", scene);
                            // explosionTexture.diffuseTexture.hasAlpha = true;
                            // explosion.material = explosionTexture;

                            // Create particle system
                            var particleSystem = new BABYLON.ParticleSystem("explosion", 2000, scene);

// Set particle texture
                            particleSystem.particleTexture = new BABYLON.Texture("./assets/textures/flare_01.png", scene);

// Set particle system properties
                            particleSystem.minSize = 0.1;
                            particleSystem.maxSize = 0.5;
                            particleSystem.minLifeTime = 0.3;
                            particleSystem.maxLifeTime = 1.5;
                            particleSystem.emitRate = 1000;
                            particleSystem.blendMode = BABYLON.ParticleSystem.BLENDMODE_ONEONE;
                            particleSystem.gravity = new BABYLON.Vector3(0, -9.81, 0);
                            particleSystem.direction1 = new BABYLON.Vector3(-1, 1, -1);
                            particleSystem.direction2 = new BABYLON.Vector3(1, -1, 1);
                            particleSystem.minAngularSpeed = 0;
                            particleSystem.maxAngularSpeed = Math.PI;
                            particleSystem.minEmitPower = 10;
                            particleSystem.maxEmitPower = 20;

// Start particle system at explosion position
                            particleSystem.emitter = grenade.position.clone();

// Start particle system
                            particleSystem.start();

                            // Remove the explosion and bullet after a short delay
                            setTimeout(function() {
                                explosion.dispose();
                                particleSystem.dispose()
                            }, 500);

                            // Create explosion effect
                            var explosion = BABYLON.Mesh.CreateSphere("explosion", 16, 5, scene);
                            explosion.position.copyFrom(grenade.position);
                            var explosionTexture = new BABYLON.StandardMaterial("explosionTexture", scene);
                            explosionTexture.diffuseTexture = new BABYLON.Texture("./assets/textures/flare_01.png", scene);
                            explosionTexture.diffuseTexture.hasAlpha = true;
                            explosion.material = explosionTexture;

                            // Remove the explosion and bullet after a short delay
                            setTimeout(function() {
                                explosion.dispose();
                            }, 500);

                            // Create bullet shells around the explosion
                            var numShells = 30;
                            for (var i = 0; i < numShells; i++) {
                                var bulletShell = BABYLON.Mesh.CreateSphere("bulletShell", 16, 1, scene);
                                bulletShell.position.copyFrom(explosion.position);
                                var randomDirection = new BABYLON.Vector3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).normalize();
                                bulletShell.physicsImpostor = new BABYLON.PhysicsImpostor(bulletShell, BABYLON.PhysicsImpostor.SphereImpostor, { mass: 0.1, restitution: 0.5 }, scene);
                                bulletShell.physicsImpostor.applyImpulse(randomDirection.scale(20), bulletShell.getAbsolutePosition());
                                setTimeout(function() {
                                    bulletShell.dispose();
                                }, 3000);
                            }

                            grenade.dispose();
                        }, 500);
                    }
                        throwGrenade()
                        break
                    case 32: // Space
                        if (wj == true) {
                            grav = 0.7;
                            wj = false;
                            spood += 0.5;
                        }
                        break;

                    case 16: // Shift - ADDED
                        speed = 5
                        break;

                    case 82: // R
                        if (care == true && aure == 0) {
                            aure = 100;
                            akm.position = new BABYLON.Vector3(0.5, -0.7, 0.5);
                            camera.fov = 1.5;
                            reload.play();
                        }
                        break;

                }

            };

            var onKeyUp = function(event) {

                switch (event.keyCode) {

                    case 32: // Space
                        break;

                    case 16: // Shift
                        speed = 2.5;
                        break;

                    case 82: // R
                        care = true;
                        break;

                }

            };

            canvas.addEventListener('keydown', onKeyDown, false);
            canvas.addEventListener('keyup', onKeyUp, false);

            scene.onDispose = function() {
                canvas.removeEventListener('keydown', onKeyDown);
                canvas.removeEventListener('keyup', onKeyUp);
            }

            var left, right;
            left = 0;
            right = 2;
            var aufi = false;
            var auti = 0;
            var auam = 30;
            var aure = 0;
            var aim = false;
            var res = 0;
            var ree = 5;
            var aufr = 5;
            aufr /= (1000/60);
            var auti = 1;
            auti /= (1000/60);
            var kickback = 0.02;



            scene.onPointerDown = (e) => {
                if (e.button === left) {
                    aufi = true;
                }
                if (e.button === right) {
                    if (aim == false) {
                        camera.fov = 1;
                        akm.position = new BABYLON.Vector3(0, -0.4125, 0.2);
                        res = 6;
                        ree = 11;
                        kickback = 0.01;
                        aim = true;
                    } else {
                        camera.fov = 1.5;
                        akm.position = new BABYLON.Vector3(0.5, -0.7, 0.5);
                        res = 0;
                        ree = 5;
                        kickback = 0.02;
                        aim = false;
                    }
                }
            }

            scene.onPointerUp = (e) => {
                if (e.button === left) {
                    aufi = false;
                }
                if (e.button === right) {

                }
            }

            var shoot = new BABYLON.Sound("gunshot", "gunshot.mp3", scene);
            var reload = new BABYLON.Sound("reload", "reload.mp3", scene);

            var si = 0;
            var sf = 0;
            var contin = true;

            var update = function() {
                console.log('update')
                // sheal.width = health/10;
                // console.wipe();
                //console.out();
                camera.speed = speed + spood;
                // console.out(dT);

                // ADDED
                camera.onCollide = function (colMesh) {
        		    if (colMesh.uniqueId === ground0.uniqueId) {
        			    wj = true;
        		    }
        	    }

                scene.gravity.y = grav;

                if (grav > -0.4) {
                    grav -= 0.05;
                }


                target.material.emissiveColor = new BABYLON.Color3(health, health, health);

                if (aufi == true && auti <= 0 && auam != 0 && aure == 0) {
                    PEW();
                    camera.rotation.x -= kickback;
                    var fire = scene.beginAnimation(akm, res, ree, false);
                    shoot.play();
                    auti = 100;
                    auam--;
                }

                if (auti >= 0) auti -= dT;

                if (health < 0.01) {
                    health = 1;
                    target.position.x += 5;
                }

                if (aure != 0) aure--;
                if (aure == 1) auam = 30;

                ammocount.text = auam+"";
                ammocount.leftInPixels = canvas.width/2.1;

            }


            scene.registerBeforeRender(function() {
                update();
                updateDT();
                //keypress();

                // bullet.physicsImpostor = new BABYLON.PhysicsImpostor(bullet, BABYLON.PhysicsImpostor.SphereImpostor, { mass: 1, restitution: 0.1, friction: 0.2 }, scene);
            });

            canvas.focus();

            return scene;
        }
        window.initFunction = async function() {
            var asyncEngineCreation = async function() {
                try {
                return createDefaultEngine();
                } catch(e) {
                console.log("the available createEngine function failed. Creating the default engine instead");
                return createDefaultEngine();
                }
            }

            window.engine = await asyncEngineCreation();
            if (!engine) throw 'engine should not be null.';
            startRenderLoop(engine, canvas);
            // window.scene = createScene();
        };

        initFunction().then(() => {sceneToRender = scene});

        // Resize
        // window.addEventListener("resize", function () {
        //     engine.resize();
        // });


</script>

    <script src="./js/init.js" type="module"></script>
<!--    <script src="./js/socket/Socket.js" type="module"></script>-->
</body>
</html>
